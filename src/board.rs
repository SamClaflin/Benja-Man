use std::collections::HashMap;
use crate::enums::Direction;

#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum BoardTile {
    Empty,
    Dot,
    Fruit,
    Wall,
    PowerUp,
    GhostGate
}

pub struct Board {
    matrix: Vec<Vec<BoardTile>>,
    cell_size: f32,
    offset: f32,
}

impl Board {
    pub fn new(cell_size: f32, offset: f32) -> Self {
        let key_map = HashMap::from([
            ('_', BoardTile::Empty),
            ('.', BoardTile::Dot),
            ('/', BoardTile::Fruit),
            ('#', BoardTile::Wall),
            ('o', BoardTile::PowerUp),
            ('|', BoardTile::GhostGate),
        ]);

        let mock_matrix = [
            ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '#', '#', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '#', '#', '.', '#'],
            ['#', 'o', '#', '_', '_', '#', '.', '#', '_', '_', '_', '#', '.', '#', '#', '.', '#', '_', '_', '_', '#', '.', '#', '_', '_', '#', 'o', '#'],
            ['#', '.', '#', '#', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '#', '#', '.', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '.', '#'],
            ['#', '.', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '.', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '#', '#', '#', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '#', '#', '#', '#'],
            ['_', '_', '_', '_', '_', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '_', '_', '_', '_', '_'],
            ['_', '_', '_', '_', '_', '#', '.', '#', '#', '.', '.', '.', '.', '_', '_', '.', '.', '.', '.', '#', '#', '.', '#', '_', '_', '_', '_', '_'],
            ['_', '_', '_', '_', '_', '#', '.', '#', '#', '.', '#', '#', '#', '|', '|', '#', '#', '#', '.', '#', '#', '.', '#', '_', '_', '_', '_', '_'],
            ['#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '_', '_', '_', '_', '_', '_', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#'],
            ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '_', '_', '_', '_', '_', '_', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],
            ['#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '_', '_', '_', '_', '_', '_', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#'],
            ['_', '_', '_', '_', '_', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '_', '_', '_', '_', '_'],
            ['_', '_', '_', '_', '_', '#', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '#', '_', '_', '_', '_', '_'],
            ['_', '_', '_', '_', '_', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '_', '_', '_', '_', '_'],
            ['#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '#', '#', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '#', '#', '.', '#'],
            ['#', '.', '#', '#', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '#', '#', '.', '#'],
            ['#', 'o', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '_', '_', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', 'o', '#'],
            ['#', '#', '#', '.', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '.', '#', '#', '#'],
            ['#', '#', '#', '.', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '.', '#', '#', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#'],
            ['#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
        ];

        let mut matrix: Vec<Vec<BoardTile>> = Vec::new();
        for row in mock_matrix.iter() {
            let mut curr_row = Vec::new();
            for val in row.iter() {
                curr_row.push(*key_map.get(val).unwrap());
            }
            matrix.push(curr_row);
        }

        Self {
            matrix,
            cell_size,
            offset
        }
    }

    pub fn try_get(&self, i: usize, j: usize) -> Option<BoardTile> {
        if self.indeces_valid(i, j) {
            Some(self.matrix[i][j])
        } else if j == self.width() {
            Some(self.matrix[i][0])
        } else if j == 0 {
            Some(self.matrix[i][self.width() - 1])
        } else {
            None
        }
    }

    pub fn width(&self) -> usize {
        self.matrix[0].len()
    }

    pub fn height(&self) -> usize {
        self.matrix.len()
    }

    pub fn cell_size(&self) -> f32 {
        self.cell_size
    }

    pub fn offset(&self) -> f32 {
        self.offset
    }

    pub fn indeces_to_coordinates(&self, i: usize, j: usize) -> (f32, f32) {
        self.validate_indeces(i, j);
        let x = j as f32 * self.cell_size + self.offset;
        let y = (self.height() - i - 1) as f32 * self.cell_size + self.offset;
        (x, y)
    }

    pub fn coordinates_to_indeces(&self, x: f32, y: f32) -> (usize, usize) {
        let i = ((self.offset - y) / self.cell_size + self.height() as f32 - 1.) as usize;
        let j = ((x - self.offset) / self.cell_size) as usize;
        (i, j)
    }

    pub fn get_coordinates(&self, x: f32, y: f32, direction: Direction, speed: f32) -> (f32, f32) {
        match direction {
            Direction::Up => {
                let mut target_y = y + speed;
                if target_y > self.height() as f32 * self.cell_size() {
                    target_y = 0.;
                }
                (x, target_y)
            },
            Direction::Right => {
                let mut target_x = x + speed;
                if target_x > self.width() as f32 * self.cell_size() {
                    target_x = 0.;
                }
                (target_x, y)
            },
            Direction::Down => {
                let mut target_y = y - speed;
                if target_y < 0. {
                    target_y = self.width() as f32 * self.cell_size();
                }
                (x, target_y)
            },
            Direction::Left => {
                let mut target_x = x - speed;
                if target_x < 0. {
                    target_x = self.width() as f32 * self.cell_size();
                }
                (target_x, y)
            }
        }
    }

    fn validate_indeces(&self, i: usize, j: usize) {
        if !self.indeces_valid(i, j) {
            panic!("Received invalid indeces: ({}, {})", i, j);
        }
    }

    fn indeces_valid(&self, i: usize, j: usize) -> bool {
        i < self.matrix.len() && j < self.matrix[0].len()
    }
}
